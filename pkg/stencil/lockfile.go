// Copyright 2022 Outreach Corporation. All Rights Reserved.

// Description: API for interacting with stencil.

// Package stencil provides an entry point for interacting with Stencil.
package stencil

import (
	"fmt"
	"os"
	"path/filepath"
	"slices"
	"sort"

	"go.rgst.io/stencil/internal/modules/resolver"
	"gopkg.in/yaml.v3"
)

// This block contains constants of the lockfiles
const (
	// LockfileName is the name of the lockfile used by stencil
	LockfileName = "stencil.lock"
)

// LockfileModuleEntry is an entry in the lockfile for a module
// that was used during the last run of stencil.
type LockfileModuleEntry struct {
	// Name is the name of the module. This usually comes from
	// the TemplateManifest entry, but is up to the module
	// package.
	Name string

	// URL is the url of the module that was used.
	URL string

	// Version is the version of the module that was
	// downloaded at the time.
	Version *resolver.Version
}

// LockfileFileEntry is an entry in the lockfile for a file
// that was generated by stencil. This contains metadata on what
// generated it among other future information
type LockfileFileEntry struct {
	// Name is the relative file path, to the invocation of stencil,
	// of the generated file
	Name string

	// Template is the template that generated this file in the given
	// module.
	Template string

	// Module is the URL of the module that generated this file.
	Module string
}

// Lockfile is generated by stencil on a ran to store version
// information.
type Lockfile struct {
	// Version correlates to the version of bootstrap
	// that generated this file.
	Version string `yaml:"version"`

	// Modules is a list of modules and their versions that was
	// used the last time stencil was ran.
	// Note: This is only set in stencil.lock
	Modules []*LockfileModuleEntry `yaml:"modules"`

	// Files is a list of files and metadata about them that were
	// generated by stencil
	Files []*LockfileFileEntry `yaml:"files"`
}

// LoadLockfile loads a lockfile at the specified path. If 'path' is
// empty, the default path (curdir+LockfileName) is used.
func LoadLockfile(path string) (*Lockfile, error) {
	f, err := os.Open(filepath.Join(path, LockfileName))
	if err != nil {
		return nil, err
	}
	defer f.Close()

	var lock *Lockfile
	err = yaml.NewDecoder(f).Decode(&lock)
	return lock, err
}

// MergeMissingInfoFromOlderLockfile merges missing files and modules from the older lockfile into the current one, for use with file.Once.
func (lf *Lockfile) MergeMissingInfoFromOlderLockfile(older *Lockfile) {
	for _, f := range older.Files {
		if !slices.ContainsFunc(lf.Files, func(fe *LockfileFileEntry) bool {
			return fe.Name == f.Name
		}) {
			lf.Files = append(lf.Files, f)
		}
	}

	for _, f := range older.Modules {
		if !slices.ContainsFunc(lf.Modules, func(fe *LockfileModuleEntry) bool {
			return fe.Name == f.Name
		}) {
			lf.Modules = append(lf.Modules, f)
		}
	}

	lf.Sort()
}

// Sort maintains the alphabetic sort of files/modules to ensure deterministic output
func (lf *Lockfile) Sort() {
	sort.SliceStable(lf.Files, func(i, j int) bool {
		return lf.Files[i].Name < lf.Files[j].Name
	})

	sort.SliceStable(lf.Modules, func(i, j int) bool {
		return lf.Modules[i].Name < lf.Modules[j].Name
	})
}

// Write writes the finished lockfile out to disk
func (lf *Lockfile) Write() error {
	f, err := os.Create(LockfileName)
	if err != nil {
		return fmt.Errorf("failed to create lockfile: %w", err)
	}
	defer f.Close()

	enc := yaml.NewEncoder(f)
	defer enc.Close()

	if err := enc.Encode(lf); err != nil {
		return fmt.Errorf("failed to write lockfile: %w", err)
	}

	return nil
}

func (lf *Lockfile) PruneFiles(onlyFiles []string) []string {
	missingFilesList := []*LockfileFileEntry{}
	for _, lf := range lf.Files {
		if len(onlyFiles) > 0 && !slices.Contains(onlyFiles, lf.Name) {
			continue
		}
		if _, err := os.Stat(lf.Name); !os.IsNotExist(err) {
			continue
		}

		missingFilesList = append(missingFilesList, lf)
	}

	missingFilenames := []string{}
	for _, lff := range missingFilesList {
		missingFilenames = append(missingFilenames, lff.Name)
		idx := slices.Index(lf.Files, lff)
		lf.Files = slices.Delete(lf.Files, idx, idx+1)
	}

	return missingFilenames
}

func (lf *Lockfile) PruneModules(newModuleNames []string, onlyModules []string) []string {
	missingModulesList := []*LockfileModuleEntry{}
	for _, lf := range lf.Modules {
		if len(onlyModules) > 0 && !slices.Contains(onlyModules, lf.Name) {
			continue
		}
		if slices.Contains(newModuleNames, lf.Name) {
			continue
		}

		missingModulesList = append(missingModulesList, lf)
	}

	missingModuleNames := []string{}
	for _, lff := range missingModulesList {
		missingModuleNames = append(missingModuleNames, lff.Name)
		idx := slices.Index(lf.Modules, lff)
		lf.Modules = slices.Delete(lf.Modules, idx, idx+1)
	}

	return missingModuleNames
}
