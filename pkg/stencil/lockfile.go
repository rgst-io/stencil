// Copyright (C) 2024 stencil contributors
// Copyright (C) 2022-2023 Outreach Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Description: API for interacting with stencil.

// Package stencil provides an entry point for interacting with Stencil.
package stencil

import (
	"fmt"
	"os"
	"path/filepath"
	"slices"
	"sort"

	"github.com/jaredallard/vcs/resolver"
	"sigs.k8s.io/yaml"
)

// This block contains constants of the lockfiles
const (
	// LockfileName is the name of the lockfile used by stencil
	LockfileName = "stencil.lock"
)

// LockfileModuleEntry is an entry in the lockfile for a module
// that was used during the last run of stencil.
type LockfileModuleEntry struct {
	// Name is the name of the module. This usually comes from
	// the TemplateManifest entry, but is up to the module
	// package.
	Name string `json:"name"`

	// URL is the full URL that was used for this module.
	URL string `json:"url"`

	// Version is the version of the module that was
	// downloaded at the time.
	Version *resolver.Version `json:"version"`
}

// LockfileFileEntry is an entry in the lockfile for a file
// that was generated by stencil. This contains metadata on what
// generated it among other future information
type LockfileFileEntry struct {
	// Name is the relative file path, to the invocation of stencil,
	// of the generated file
	Name string `json:"name"`

	// Template is the template that generated this file in the given
	// module.
	Template string `json:"template"`

	// Module is the import path (Name) of the module that generated this
	// file.
	Module string `json:"module"`
}

// Lockfile is generated by stencil on a ran to store version
// information.
type Lockfile struct {
	// Version correlates to the version of bootstrap
	// that generated this file.
	Version string `json:"version"`

	// Modules is a list of modules and their versions that was
	// used the last time stencil was ran.
	// Note: This is only set in stencil.lock
	Modules []*LockfileModuleEntry `json:"modules"`

	// Files is a list of files and metadata about them that were
	// generated by stencil
	Files []*LockfileFileEntry `json:"files"`
}

// LoadLockfile loads a lockfile at the specified path. If 'path' is
// empty, the default path (curdir+LockfileName) is used.
func LoadLockfile(path string) (*Lockfile, error) {
	//nolint:gosec // Why: Not user input.
	b, err := os.ReadFile(filepath.Join(path, LockfileName))
	if err != nil {
		return nil, err
	}

	var lock Lockfile
	return &lock, yaml.Unmarshal(b, &lock)
}

// MergeMissingInfoFromOlderLockfile merges missing files and modules from the older lockfile into the current one, for use with file.Once.
func (lf *Lockfile) MergeMissingInfoFromOlderLockfile(older *Lockfile) {
	for _, f := range older.Files {
		if !slices.ContainsFunc(lf.Files, func(fe *LockfileFileEntry) bool {
			return fe.Name == f.Name
		}) {
			lf.Files = append(lf.Files, f)
		}
	}

	for _, f := range older.Modules {
		if !slices.ContainsFunc(lf.Modules, func(fe *LockfileModuleEntry) bool {
			return fe.Name == f.Name
		}) {
			lf.Modules = append(lf.Modules, f)
		}
	}

	lf.Sort()
}

// Sort maintains the alphabetic sort of files/modules to ensure deterministic output
func (lf *Lockfile) Sort() {
	sort.SliceStable(lf.Files, func(i, j int) bool {
		return lf.Files[i].Name < lf.Files[j].Name
	})

	sort.SliceStable(lf.Modules, func(i, j int) bool {
		return lf.Modules[i].Name < lf.Modules[j].Name
	})
}

// Write writes the finished lockfile out to disk
func (lf *Lockfile) Write() error {
	f, err := os.Create(LockfileName)
	if err != nil {
		return fmt.Errorf("failed to create lockfile: %w", err)
	}
	defer f.Close()

	b, err := yaml.Marshal(lf)
	if err != nil {
		return fmt.Errorf("failed to marshal lockfile: %w", err)
	}

	if _, err := f.Write(b); err != nil {
		return fmt.Errorf("failed to write lockfile: %w", err)
	}

	return nil
}

// PruneFiles prunes files form the lockfile.
func (lf *Lockfile) PruneFiles(onlyFiles []string) []string {
	missingFilesList := []*LockfileFileEntry{}
	for _, lf := range lf.Files {
		if len(onlyFiles) > 0 && !slices.Contains(onlyFiles, lf.Name) {
			continue
		}
		if _, err := os.Stat(lf.Name); !os.IsNotExist(err) {
			continue
		}

		missingFilesList = append(missingFilesList, lf)
	}

	missingFilenames := []string{}
	for _, lff := range missingFilesList {
		missingFilenames = append(missingFilenames, lff.Name)
		idx := slices.Index(lf.Files, lff)
		lf.Files = slices.Delete(lf.Files, idx, idx+1)
	}

	return missingFilenames
}

// PruneModules prunes modules from the lockfile
func (lf *Lockfile) PruneModules(newModuleNames, onlyModules []string) []string {
	missingModulesList := []*LockfileModuleEntry{}
	for _, lf := range lf.Modules {
		if len(onlyModules) > 0 && !slices.Contains(onlyModules, lf.Name) {
			continue
		}
		if slices.Contains(newModuleNames, lf.Name) {
			continue
		}

		missingModulesList = append(missingModulesList, lf)
	}

	missingModuleNames := []string{}
	for _, lff := range missingModulesList {
		missingModuleNames = append(missingModuleNames, lff.Name)
		idx := slices.Index(lf.Modules, lff)
		lf.Modules = slices.Delete(lf.Modules, idx, idx+1)
	}

	return missingModuleNames
}
